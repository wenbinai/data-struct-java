package com.example.linklistexercise;

import com.example.linklist.ListNode;

import java.util.List;


/**
 * 链表练习题
 */
public class LinkListExercise {
    /**
     * 利用链表实现栈
     */
    public void LinkListStack() {

    }

    /**
     * 找到链表的倒数第k个节点
     *
     * @param k
     * @return
     */
    public ListNode findReverseKNode(int k) {
        // 1. 暴力

        // 2. 设计散列表

        // 3. 扫描法(两次, 一次)

        return null;
    }

    /**
     * 判断给定头节点的链表是否为循环链表
     *
     * @param headNode
     * @return
     */
    public boolean isCirculList(ListNode headNode) {
        // 1. 暴力法

        // 2. 散列表

        // 3. 排序技术

        // 4. Floyd环判定法

        return false;
    }

    /**
     * 判断给定的链表是否为回文链表
     *
     * @param headNode
     * @return
     */
    public boolean isHuiWenList(ListNode headNode) {
        return false;
    }

    /**
     * 交换链表中相邻的节点
     *
     * @param headNode
     * @return
     */
    public ListNode exchangeAdjacentNodes(ListNode headNode) {
        return null;
    }

    /**
     * 倒置K个节点
     * 输入: 1 2 3 4 5 6 7 8 9  k=3
     * 输出: 3 2 1 6 5 4 9 8 7
     *
     * @param k
     * @param head
     * @return
     */
    public ListNode getKPlusOneThNode(int k, ListNode head) {
        return null;
    }

    /**
     * 约瑟夫环问题
     * N个人选出一个领头人, 排成一个环, M位置删除, 并从一个人开始重新计数
     *
     * @param n
     * @param m
     * @return
     */
    public ListNode getJosephusPosition(int n, int m) {
        return null;
    }

    /**
     * 复制链表
     * 给定一个链表, 每个节点包含数据, 下一个指针, 一个指向链表某个节点的随机指针
     *
     * @param headNode
     * @return
     */
    public ListNode clone(ListNode headNode) {
        return null;
    }

    /**
     * 合并两个有序链表
     *
     * @param a
     * @param b
     * @return
     */
    public ListNode mergeList(ListNode a, ListNode b) {
        return null;
    }

    /**
     * 倒置链表
     *
     * @param headNode
     * @return
     */
    public ListNode reverseList(ListNode headNode) {
        return null;
    }

    /**
     * 倒置成对的链表
     * 1-2-3-4-x
     * 2-1-4-3-x
     *
     * @param headNode
     * @return
     */
    public ListNode reversePairList(ListNode headNode) {
        return null;
    }

    /**
     * 找到链表的中间节点
     *
     * @param headNode
     * @return
     */
    public ListNode findMiddleNode(ListNode headNode) {
        // 1. 暴力

        // 2. 散列表

        // 3. 扫描
        return null;
    }




}
